Resumen rápido y opinión sobre los modelos (en español):

Puntos fuertes (ambos modelos)

Relaciones claras y coherentes: usan BelongsTo, HasMany, MorphMany y BelongsToMany correctamente. Esto facilita navegación y queries Eloquent.
fillable bien definido en ambos (reduce riesgo de mass assignment si se usa con cuidado).
Client ya incluye un mutator robusto para normalizar teléfono usando libphonenumber (muy buena práctica para consistencia y formato E.164).
Contact contempla la relación con Establishment y SequenceEnrollment, lo que muestra integración con el workflow del CRM.
Observaciones y recomendaciones concretas

Normalización consistente de teléfono y correo
Situación: Client tiene un mutator setPhoneAttribute() que normaliza a E.164 usando libphonenumber. Contact no lo tiene; Lead (por lo que vi antes) usa solo campos sin este tratamiento.
#COMPLETADO 
Recomendación: centralizar la lógica de normalización/validación de teléfonos en un Trait reutilizable, p. ej. App\Models\Concerns\NormalizesPhone y aplicarlo a Client, Contact y Lead. Esto evita duplicación y errores por inconsistencias.
Igual para emails: un pequeño mutator para email que haga strtolower() y trim() ayuda a evitar duplicados y problemas de búsqueda.
Casts y atributos por defecto
Observación: Client y Contact no tienen protected $casts (salvo el mutator de phone en Client). Lead sí define casts extensos.

#cOMPLETADO
Recomendación: agregar casts útiles:
'active' => 'boolean' (ya existe como atributo en ambos, pero should cast)
fechas (created_at, updated_at) están manejadas por Eloquent; si hay otros campos fecha, castear a datetime.
arrays (si tienes custom_fields o social_profiles en otros modelos).
También usar protected $attributes para defaults (ya usas active => 1 en ambos; bien).
Indices y performance en BD
Observación: modelos exponen campos que probablemente se busquen por email/phone/user_id.
#Recomendación: en migraciones, añadir índices en columnas frecuentemente consultadas:
índice único/normal en email (si aplica) o índice parcial si se permiten nulos
índice en phone
índice en user_id y active
índices compuestos para búsquedas comunes (ej. user_id + active)
Integridad y transacciones


#COMPLETADO
Observación: en Lead::convertToClient() (archivo Lead), haces una transacción para crear Client, Contact, Deal, etc. Excelente.
#Recomendación: mantener misma disciplina al crear/actualizar Client con entidades relacionadas; por ejemplo, si hay endpoints que crean cliente + establecimientos + contactos, envolver en transacción.
Validaciones y reglas

#COMPLETADO
Observación: modelos no hacen validación beyond normalización.
#Recomendación: mantener reglas en FormRequests/Services para validar antes de persistir (p.ej. ClientRequest, ContactRequest) y usar tests que cubran esas reglas. En el modelo, mutators aseguran formato, pero no reemplazan la validación de negocio.
Soft deletes y auditoría
Pregunta/consideración: ¿querés conservar histórico cuando se eliminan clientes/contactos? Si sí, agregar use SoftDeletes y migraciones con softDeletes().
Además, considerar auditing (paquete o events) para registrar quién creó/actualizó/eliminó.
Tipado y PHPDoc


#Recomendación: añadir docblocks a métodos de relaciones y mutators, y return types (ya usas los tipos en algunas relaciones). Ayuda al IDE y al mantenimiento.
Consistencia de nombres y campos
Observación: Client tiene tanto name como company. En Lead usas name y company también. Es importante definir la semántica: usar company para la empresa y name para el contacto. Documentalo para evitar duplicación de datos al convertir leads.
#Recomendación: en conversiones, decidir reglas: si company vacío usar name como nombre de cliente (tal como ya haces), pero dejar esto documentado y cubierto por tests.

Tests y cobertura
#Recomendación: añadir tests unitarios/feature mínimos:
Mutator de Client::setPhoneAttribute() -> valida que transforma varios formatos a E.164.
Relaciones: crear client con contacts y establishments y assert relaciones.
Conversion de Lead->Client fluxo (ya existe en Lead) => testear integridad e histórico.
Seguridad en fillable vs guarded
Observación: fillable granular es bueno. Asegurate de que no falten campos sensibles en la lista si expones endpoints públicos.
#Recomendación: preferir fillable en modelos con formularios controlados y validar en FormRequests.
Ideas de mejora concretas (de baja complejidad para implementar ahora)

#Crear Trait NormalizesPhone y aplicarlo en Contact (y Lead si falta).
#Añadir protected $casts = ['active' => 'boolean'] en ambos modelos.
#Añadir mutator setEmailAttribute() en ambos para normalizar.
#Agregar índices en migraciones para email, phone, user_id.
#Añadir tests unitarios para el mutator de teléfono y las relaciones.
#Conclusión breve

La base está muy bien: relaciones y uso de libphonenumber en Client son puntos fuertes. Falta algo de consistencia (phone/email normalization) entre Client, Contact y Lead, y algunos casts y pequeñas mejoras estructurales (índices, tests, soft deletes opcional). Implementar un Trait de normalización y añadir casts/índices sería alto retorno con bajo esfuerzo.
¿Querés que implemente ahora alguna de las mejoras concretas? Puedo:

crear el Trait NormalizesPhone y aplicarlo a Contact y Lead; y agregar setEmailAttribute() en los tres modelos; o
agregar casts y tests mínimos para el mutator de teléfono.


Observaciones y recomendaciones (prioritarias)

Coherencia de SoftDeletes
Estado: aplicaste SoftDeletes en Client y Contact, pero Establishment no lo tiene.
Recomendación: añadir SoftDeletes a Establishment para mantener comportamiento coherente cuando se quiere "eliminar" un cliente y conservar su historial. También decidir la política de cascada (ver punto 3).
Casts y atributos por defecto
Recomendación: añadir en Establishment:
protected $casts = ['active' => 'boolean', 'latitude' => 'float', 'longitude' => 'float', 'deleted_at' => 'datetime'];
protected $attributes = ['active' => 1]; (si querés el mismo comportamiento que en Client y Contact).
Esto mejora serialización y evita sorpresas al leer valores.
Cascada lógica al borrar/restaurar
Pregunta clave: cuando borrás (soft delete) un Client, ¿querés que sus Establishments y Contacts se soft-delete también?
Opciones:
Implementar observers (modelo deleting/restoring) para propagar soft deletes/restore.
Usar jobs/queues si la operación debe ser asíncrona para no bloquear requests.
Recomendación: implementar observers simples que en deleting hagan $model->relations()->each->delete() y en restoring restauren.
Índices y performance
Ya añadiste índices para clients, contacts y leads.
Recomendación: añadir índice en establishments.client_id y en establishments.active si vas a filtrar por cliente/activo frecuentemente. Puedo crear una migración pequeña para eso.
Validaciones y FormRequests
Recomendación: asegurar validaciones en ClientRequest, ContactRequest, EstablishmentRequest (por ejemplo: lat/long numeric, zip max length, email format). Los mutators normalizan pero la validación previene datos inválidos.




Recomendación de Estructura de Permisos:

Niveles de Acceso Propuestos:
Modificar Controllers para Respetar Visibilidad:
Implementar Políticas de Acceso:
Mejorar el Middleware IsAdmin:
Vista de Administración Mejorada:
Recomendaciones de Implementación:


Para Administradores:
Ver todos los registros por defecto
Acceso a estadísticas globales
Capacidad de gestionar usuarios
Ver/editar cualquier registro
Acceso a métricas de rendimiento

Para Usuarios Normales:
Ver solo sus propios registros
Estadísticas limitadas a sus datos
Gestionar sus propios clientes/deals
Sin acceso a datos de otros usuarios
Funcionalidades Adicionales para Admin:
Vistas Separadas pero Mantenibles:
¿Querés que implemente alguna de estas mejoras? Podemos:

Mejorar el sistema de roles/permisos
Implementar las políticas de acceso
Añadir las vistas y controles de administración
Crear un dashboard específico para administradores